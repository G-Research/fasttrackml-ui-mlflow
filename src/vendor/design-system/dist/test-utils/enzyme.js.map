{"version":3,"file":"enzyme.js","sources":["../../src/test-utils/enzyme/utils.ts","../../src/test-utils/enzyme/selectEvent.ts","../../src/test-utils/enzyme/table.ts","../../src/test-utils/enzyme/index.ts"],"sourcesContent":["// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\nimport { act } from 'react-dom/test-utils';\n\ninterface QueryOptions {\n  /** Whether to trim the whitespace from DOM text using `String.prototype.trim` */\n  trim?: boolean;\n}\n\n/**\n * Finds a single element that contains the specified text in the wrapper. If\n * there are 0 or more than 1 element that contains the specified text, an error\n * is thrown. Returns the element in an enzyme wrapper.\n */\nexport function findByText<P, S, C>(\n  wrapper: ReactWrapper<P, S, C>,\n  text: string | RegExp,\n  queryOptions?: QueryOptions\n) {\n  const newWrappers = findAllByText<P, S, C>(wrapper, text, queryOptions);\n  if (newWrappers.length !== 1) {\n    throw new Error(\n      `Expected to find 1 node but found ${newWrappers.length} nodes for text \"${text}\".\\n${wrapper.debug()}`\n    );\n  }\n  return newWrappers[0];\n}\n\n/**\n * Finds all elements that contain the specified text. To avoid duplicate results,\n * only the parents of text nodes are returned.\n */\nexport function findAllByText<P, S, C>(\n  wrapper: ReactWrapper<P, S, C>,\n  text: string | RegExp,\n  { trim = false }: QueryOptions = {}\n) {\n  const textNodes = wrapper.findWhere((n) => {\n    if (n.type() !== undefined) {\n      return false;\n    }\n\n    let nodeText = n.text();\n    if (trim) {\n      nodeText = nodeText.trim();\n    }\n\n    return typeof text === 'string' ? nodeText === text : text.test(nodeText);\n  });\n  const newWrappers = textNodes.map((n) => {\n    const textNodeParent = n.parents().first();\n    if (textNodeParent.name() === 'FormattedMessage') {\n      // Try not to return FormattedMessage since it breaks `simulate` due to a bug in `enzyme-adapter-react-17`\n      // Similar to https://github.com/wojtekmaj/enzyme-adapter-react-17/issues/45\n      const formattedMessageParents = textNodeParent.parents();\n      return formattedMessageParents.length > 0 ? formattedMessageParents.first() : textNodeParent;\n    } else {\n      return textNodeParent;\n    }\n  });\n  return newWrappers;\n}\n\n// We need to keep ref to original setTimeout to avoid SinonJS fake timers if enabled\nconst originalSetTimeout = window.setTimeout;\n\n/**\n * This is so the stack trace the developer sees is one that's\n * closer to their code (because async stack traces are hard to follow).\n *\n * The code is taken from\n * https://github.com/testing-library/dom-testing-library/blob/f7b5c33c44632fba\n * 1579cb44f9f175be1ec46087/src/wait-for.js#L15-L19\n */\nfunction copyStackTrace(target: Error, source: Error) {\n  // eslint-disable-next-line no-param-reassign\n  target.stack = source.stack!.replace(source.message, target.message);\n}\n\ninterface WaitForOptions {\n  interval?: number;\n  stackTraceError?: Error;\n  timeout?: number;\n}\n\n/**\n * Run an expectation until it succeeds or reaches the timeout. The timeout of 1500ms\n * is chosen to be under the default Karma test timeout of 2000ms. This function will\n * not work properly if fake timers are being used (since it expects the real setTimeout).\n *\n * The code is taken from\n * https://github.com/TheBrainFamily/wait-for-expect/blob/master/src/index.ts,\n * with slight modifications to support Karma (instead of Jest).\n *\n *\n * Example\n * The <App /> component does not render the header synchronously.\n * Therefore, we cannot check that the wrapper's text is equal to the string\n * immediately--this assertion will fail and cause the test to fail. To\n * remediate this issue, we can run the expectation until it succeeds:\n *\n * function App() {\n *   const [value, setValue] = useState(null);\n *   useEffect(() => {\n *     const timeoutId = setTimeout(() => setValue(\"some value\"), 100);\n *     return () => clearTimeout(timeoutId);\n *   }, []);\n *   return value === null ? null : <h1>The value is: {value}</h1>;\n * }\n *\n * it('renders value', async () => {\n *   const wrapper = mount(<App />);\n *   await waitFor(() =>\n *     wrapper.update();\n *     expect(wrapper.text()).to.equal(\"The value is: some value\")\n *   );\n * });\n */\nfunction _waitFor<T>(\n  f: () => T | Promise<T>,\n  { interval = 50, stackTraceError, timeout = 1500 }: WaitForOptions = {}\n): Promise<T> {\n  const maxTries = Math.ceil(timeout / interval);\n  let tries = 0;\n  return new Promise((resolve, reject) => {\n    const rejectOrRerun = (error: Error) => {\n      if (tries > maxTries) {\n        if (stackTraceError !== undefined) {\n          copyStackTrace(error, stackTraceError);\n        }\n        reject(error);\n        return;\n      }\n      originalSetTimeout(runExpectation, interval);\n    };\n\n    function runExpectation() {\n      tries += 1;\n      try {\n        Promise.resolve(f()).then(resolve).catch(rejectOrRerun);\n      } catch (error) {\n        // @ts-expect-error ts-migrate(2571) Object is of type 'unknown'\n        rejectOrRerun(error);\n      }\n    }\n\n    originalSetTimeout(runExpectation, 0);\n  });\n}\n\n/**\n * Wraps `_waitFor` in React's `act` testing utility. Used when the React component\n * updates during the execution of the callback (either because of indirect effects\n * being run or because of direct requests to update the component, like wrapper.update).\n * Prevents updates related to the callback from being affected by other updates\n * and more closely mimics how React runs in the browser. See\n * https://reactjs.org/docs/test-utils.html#act for more info on `act`.\n */\nexport async function waitFor<T>(callback: () => T | Promise<T>, options?: WaitForOptions): Promise<T> {\n  let result: T | Promise<T>;\n  // See https://github.com/testing-library/dom-testing-library/blob/f7b5c33c44\n  // 632fba1579cb44f9f175be1ec46087/src/wait-for.js#L182-L184\n  const stackTraceError = new Error('STACK_TRACE_ERROR');\n\n  await act(async () => {\n    result = await _waitFor(callback, { stackTraceError, ...options });\n  });\n\n  // @ts-expect-error: either `waitFor` will throw or `result` will be assigned\n  return result;\n}\n\n/**\n * Finds all elements (that are rendered in the DOM) in `wrapper` that have an explicit\n * role of `role` specified. This is similar to `getAllByRole` from @testing-library/react\n * but is much simpler because of the shortcomings of Enzyme's API.\n */\nexport function findAllByRole(wrapper: ReactWrapper, role: string): ReactWrapper[] {\n  return wrapper\n    .find(`[role=\"${role}\"]`)\n    .hostNodes()\n    .map((n) => n);\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nimport { selectClasses } from '../common';\nimport { findByText, waitFor } from './utils';\n\n/**\n * Clicks on the \"Clear\" button. In order for this function to work properly,\n * the `allowClear` prop must be set to `true`.\n */\nexport function clearAll(getSelect: () => ReactWrapper): void {\n  getSelect().find(`.${selectClasses.clear}`).hostNodes().simulate('mousedown');\n}\n\n/**\n * Closes the dropdown menu for the <Select/> by clicking. Will throw an error if\n * the menu is already closed or if the menu is unable to be closed.\n */\nexport async function closeMenu(getSelect: () => ReactWrapper): Promise<void> {\n  if (!getSelect().find(`.${selectClasses.open}`).exists()) {\n    throw new Error(`Select is already closed\\n${getSelect().debug()}`);\n  }\n  getSelect().find(`.${selectClasses.selector}`).simulate('mousedown');\n  await waitFor(() => {\n    const select = getSelect();\n    if (select.find(`.${selectClasses.open}`).exists()) {\n      throw new Error(`Select did not close\\n${select.debug()}`);\n    }\n  });\n}\n\n/**\n * Returns a string concatenating the labels for all selected options.\n */\nexport function getLabelText(getSelect: () => ReactWrapper): string {\n  // Trim the text to avoid weird whitespace issues non-label elements being added.\n  // For example, the input mirror is an empty span with some whitespace that is\n  // nested under the selector but does not show up in the label text.\n  return getSelect().find(`.${selectClasses.selector}`).text().trim();\n}\n\n/**\n * Selects options from the dropdown menu for a <Select/> component with `mode=\"multiple\"`.\n * The provided strings must match the option labels exactly. There is a known\n * limitation for lists that are extremely long because AntD virtualizes the\n * options so not all may options may be rendered in the DOM. If this is causing\n * you issues, please let #help-frontend know.\n */\nexport async function multiSelect(getSelect: () => ReactWrapper, options: string[]): Promise<void> {\n  await openMenu(getSelect);\n  options.forEach((option) => {\n    findByText(getSelect().find(`.${selectClasses.list}`), option).simulate('click');\n  });\n  // Close the menu to indicate that selection has finished\n  await closeMenu(getSelect);\n}\n\n/**\n * Selects options from the dropdown menu for a <Select/> component without a\n * mode. The provided string must match an option label exactly. There is a known\n * limitation for lists that are extremely long because AntD virtualizes the\n * options so not all may options may be rendered in the DOM. If this is causing\n * you issues, please let #help-frontend know.\n */\nexport async function singleSelect(getSelect: () => ReactWrapper, option: string): Promise<void> {\n  await openMenu(getSelect);\n  findByText(getSelect().find(`.${selectClasses.list}`), option).simulate('click');\n  // Menu automatically closes for a single <Select/> (no mode=\"multiple\")\n}\n\n/**\n * Opens the dropdown menu for the <Select/> by clicking. Will throw an error if\n * the menu is already opened or if the menu is unable to be opened.\n */\nexport async function openMenu(getSelect: () => ReactWrapper): Promise<void> {\n  if (getSelect().find(`.${selectClasses.open}`).exists()) {\n    throw new Error(`Select is already open\\n${getSelect().debug()}`);\n  }\n  getSelect().find(`.${selectClasses.selector}`).simulate('mousedown');\n  await waitFor(() => {\n    const select = getSelect();\n    if (!select.find(`.${selectClasses.open}`).exists()) {\n      throw new Error(`Select did not open\\n${select.debug()}`);\n    }\n  });\n}\n\n/**\n * Opens the dropdown menu, finds all of the options in the dropdown, closes\n * the menu, and returns a list of the text of each option in order.\n */\nexport async function getAllOptions(getSelect: () => ReactWrapper): Promise<string[]> {\n  await openMenu(getSelect);\n  const options = getSelect()\n    .find(`.${selectClasses.list}`)\n    .find(`.${selectClasses.option}`)\n    .map((option) => option.text());\n  await closeMenu(getSelect);\n  return options;\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nimport type { GetTableRowByCellTextOptions, TableRows } from '../common';\nimport { createMarkdownTable } from '../common';\nimport { findAllByRole, findByText } from './utils';\n\n/**\n * Returns the table row that contains the specified `cellText`. The `cellText`\n * must be in the column with name `columnHeaderName` if it is specified. Otherwise,\n * the `cellText` must be in the first column. Throws an error if either multiple\n * rows or no rows can be found that match the given options. Also throws an error\n * if the column with name `columnHeaderName` cannot be found.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n * @param cellText The cell text that uniquely identifies the row.\n * @param columnHeaderName The name of the column to search the text for. If not provided,\n * the first column will be used.\n */\nexport function getTableRowByCellText(\n  tableWrapper: ReactWrapper,\n  cellText: string,\n  { columnHeaderName }: GetTableRowByCellTextOptions = {}\n): ReactWrapper {\n  let columnHeaderIndex: number;\n  if (columnHeaderName === undefined) {\n    columnHeaderIndex = 0;\n  } else {\n    const columnHeaders = findAllByRole(tableWrapper, 'columnheader');\n    columnHeaderIndex = columnHeaders.findIndex((n) => {\n      try {\n        findByText(n, columnHeaderName);\n        return true;\n      } catch {\n        return false;\n      }\n    });\n    if (columnHeaderIndex === -1) {\n      throw new Error(`Unable to find a column with name \"${columnHeaderName}\"\\n${tableWrapper.debug()}`);\n    }\n  }\n\n  const matchingRows = findAllByRole(tableWrapper, 'row')\n    // Skip first row (table header)\n    .slice(1)\n    .filter((row) => {\n      const cells = findAllByRole(row, 'cell');\n      const cell = cells[columnHeaderIndex];\n      try {\n        findByText(cell, cellText);\n        return true;\n      } catch {\n        return false;\n      }\n    });\n\n  if (matchingRows.length === 0) {\n    throw new Error(\n      `Unable to find a table row with text \"${cellText}\" in the column \"${columnHeaderName}\"\\n${tableWrapper.debug()}`\n    );\n  }\n\n  if (matchingRows.length > 1) {\n    throw new Error(\n      `Found multiple table rows with text \"${cellText}\" in the column \"${columnHeaderName}\"\\n${tableWrapper.debug()}`\n    );\n  }\n\n  return matchingRows[0].hostNodes();\n}\n\n/**\n * Converts a Du Bois table to a markdown table string. This means that each cell\n * is separated by a pipe (including the edges), the header row is on its own line\n * at the top, each data row is on its own line below, and the header row is separated\n * by a row of dashes from the data rows. This is useful for checking table contents\n * in tests.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n *\n * @example\n * The HTML table:\n * ```jsx\n *   <Table>\n *     <TableRow isHeader>\n *       <TableHeader>Name</TableHeader>\n *       <TableHeader>Fruit</TableHeader>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Alice</TableCell>\n *       <TableCell>Apple</TableCell>\n *     </TableRow>\n *     <TableRow>\n *       <TableCell>Brady</TableCell>\n *       <TableCell>Banana</TableCell>\n *     </TableRow>\n *   </Table>\n * ```\n *\n * The Markdown table:\n * ```md\n *   | Name | Fruit |\n *   | --- | --- |\n *   | Alice | Apple |\n *   | Brady | Banana |\n * ```\n */\nexport function toMarkdownTable(tableWrapper: ReactWrapper): string {\n  const { bodyRows, headerRow } = getTableRows(tableWrapper);\n  const columns = findAllByRole(headerRow, 'columnheader').map((column) => column.text());\n  const rows = bodyRows.map((row) => findAllByRole(row, 'cell').map((cell) => cell.text()));\n  return createMarkdownTable(columns, rows);\n}\n\n/**\n * Returns the header row and all body rows (non-header rows) in order. Assumes that the\n * `tableWrapper` has a single header row (as the first row) and the rest of the rows are\n * body rows.\n *\n * @param tableWrapper The ReactWrapper containing the table to query in.\n */\nexport function getTableRows(tableWrapper: ReactWrapper): TableRows<ReactWrapper> {\n  const [firstRow, ...restRows] = findAllByRole(tableWrapper, 'row');\n  return {\n    bodyRows: restRows,\n    headerRow: firstRow,\n  };\n}\n","// eslint-disable-next-line @databricks/no-restricted-imports-regexp\nimport type { ReactWrapper } from 'enzyme';\n\nexport * as selectEvent from './selectEvent';\n\nexport * from './table';\n\n/**\n * Open a dropdown menu by simulating a pointerDown event on the dropdown button.\n *\n * @param dropdownButton - The Dropdown Trigger button that opens the menu when clicked.\n */\nexport const openDropdownMenu = (dropdownButton: ReactWrapper) => {\n  dropdownButton.hostNodes().simulate('pointerDown', { button: 0, ctrlKey: false });\n};\n"],"names":["findByText","wrapper","text","queryOptions","newWrappers","findAllByText","length","Error","debug","trim","arguments","undefined","textNodes","findWhere","n","type","nodeText","test","map","textNodeParent","parents","first","name","formattedMessageParents","originalSetTimeout","window","setTimeout","copyStackTrace","target","source","stack","replace","message","_waitFor","f","interval","stackTraceError","timeout","maxTries","Math","ceil","tries","Promise","resolve","reject","rejectOrRerun","error","runExpectation","then","catch","waitFor","callback","options","result","act","findAllByRole","role","find","hostNodes","clearAll","getSelect","selectClasses","clear","simulate","closeMenu","open","exists","selector","select","getLabelText","multiSelect","openMenu","forEach","option","list","singleSelect","getAllOptions","getTableRowByCellText","tableWrapper","cellText","columnHeaderName","columnHeaderIndex","columnHeaders","findIndex","matchingRows","slice","filter","row","cells","cell","toMarkdownTable","bodyRows","headerRow","getTableRows","columns","column","rows","createMarkdownTable","firstRow","restRows","openDropdownMenu","dropdownButton","button","ctrlKey"],"mappings":"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"}